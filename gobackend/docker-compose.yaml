networks:
  coolify:
    external: true

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: openupload-go-backend
    restart: unless-stopped
    dns:
      - 8.8.8.8
      - 8.8.4.4
      - 1.1.1.1
    environment:
      PORT: ${PORT}
      FRONTEND_URL: ${FRONTEND_URL}
      DATABASE_URL: ${DATABASE_URL}
      FIREBASE_CREDENTIALS_PATH: ${FIREBASE_CREDENTIALS_PATH}
      MINIO_ENDPOINT: ${MINIO_ENDPOINT}
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
      MINIO_BUCKET: ${MINIO_BUCKET}
      MINIO_REGION: ${MINIO_REGION}
      MINIO_USE_SSL: ${MINIO_USE_SSL}
      IMGPROXY_URL: ${IMGPROXY_URL}
      STORAGE_PREFIX: ${STORAGE_PREFIX}
    volumes:
      - /home/gabriel/Desktop/open_upload/firebase:/app/firebase:ro
      - /home/gabriel/Desktop/open_upload/db:/app/db
    # Port forwarding: Uncomment when DEVELOPMENT=true
    # ports:
    #   - "${PORT}:8080"
    depends_on:
      - minio
    networks:
      - coolify

  minio:
    image: quay.io/minio/minio:latest
    container_name: minio
    # For single volume: server /data --console-address ":9001"
    # For multiple volumes: server /data1 /data2 /data3 /data4 --console-address ":9001"
    # MinIO will automatically use all volumes. With 4+ volumes, it enables erasure coding.
    command: server /data --console-address ":9001"
    restart: unless-stopped
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    volumes:
      - ${MINIO_HOST_PATH}:/data
      # To add more storage, uncomment and add additional volumes:
      # - ${MINIO_HOST_PATH_2}:/data2
      # - ${MINIO_HOST_PATH_3}:/data3
      # - ${MINIO_HOST_PATH_4}:/data4
      # Then update the command to: server /data /data2 /data3 /data4 --console-address ":9001"
    # Port forwarding: Uncomment when DEVELOPMENT=true
    # ports:
    #   - "9000:9000"  # MinIO API
    #   - "9001:9001"  # MinIO Console
    networks:
      - coolify

  imgproxy:
    image: darthsim/imgproxy:latest
    container_name: imgproxy
    restart: unless-stopped
    networks:
      - coolify

    # Port forwarding: Uncomment when DEVELOPMENT=true
    # ports:
    #   - "8081:8080"  # imgproxy (using 8081 to avoid conflict with app on 8080)
    environment:
      IMGPROXY_USE_S3: "true"
      IMGPROXY_S3_ENDPOINT: ${IMGPROXY_S3_ENDPOINT}
      IMGPROXY_S3_REGION: ${IMGPROXY_S3_REGION}
      # Use MinIO root credentials for imgproxy to access MinIO
      AWS_ACCESS_KEY_ID: ${MINIO_ROOT_USER}
      AWS_SECRET_ACCESS_KEY: ${MINIO_ROOT_PASSWORD}
      IMGPROXY_ALLOWED_SOURCES: ""

      # imgproxy signing (optional, from .env)
      IMGPROXY_KEY: ${IMGPROXY_KEY}
      IMGPROXY_SALT: ${IMGPROXY_SALT}

      # sensible defaults (hardcoded, no env vars required)
      IMGPROXY_AUTO_WEBP: "true"
      IMGPROXY_QUALITY: "85"
      IMGPROXY_MAX_SRC_RESOLUTION: "50"

    labels:
      - traefik.enable=true
      - traefik.docker.network=coolify

      # HTTP â†’ HTTPS for public CDN host
      - traefik.http.routers.imgproxy-http.entryPoints=http
      - traefik.http.routers.imgproxy-http.rule=Host(`cdn.yourdomain.com`)
      - traefik.http.routers.imgproxy-http.middlewares=redirect-to-https
      - traefik.http.routers.imgproxy-http.service=imgproxy-svc

      # HTTPS
      - traefik.http.routers.imgproxy-https.entryPoints=https
      - traefik.http.routers.imgproxy-https.rule=Host(`cdn.yourdomain.com`)
      - traefik.http.routers.imgproxy-https.middlewares=gzip
      - traefik.http.routers.imgproxy-https.tls=true
      - traefik.http.routers.imgproxy-https.tls.certresolver=letsencrypt
      - traefik.http.routers.imgproxy-https.service=imgproxy-svc

      # Long-lived cache for Cloudflare
      - traefik.http.middlewares.cdnheaders.headers.customResponseHeaders.Cache-Control=public, max-age=31536000, immutable
      - traefik.http.routers.imgproxy-https.middlewares=gzip,cdnheaders

      - traefik.http.services.imgproxy-svc.loadbalancer.server.port=8080
